"use strict";(self.webpackChunkdocs_docusaurus=self.webpackChunkdocs_docusaurus||[]).push([[2235],{28453:(e,n,s)=>{s.d(n,{R:()=>l,x:()=>o});var t=s(96540);const i={},a=t.createContext(i);function l(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),t.createElement(a.Provider,{value:n},e.children)}},60488:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>r,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"core-concepts/scripting/inheriting-classes","title":"Inheriting Classes","description":"How to inherit nanos world Classes","source":"@site/i18n/de/docusaurus-plugin-content-docs/current/core-concepts/scripting/inheriting-classes.md","sourceDirName":"core-concepts/scripting","slug":"/core-concepts/scripting/inheriting-classes","permalink":"/de/docs/next/core-concepts/scripting/inheriting-classes","draft":false,"unlisted":false,"editUrl":"https://crowdin.com/project/nanos-world-docs/de","tags":[{"inline":true,"label":"scripting","permalink":"/de/docs/next/tags/scripting"}],"version":"current","lastUpdatedBy":null,"lastUpdatedAt":null,"sidebarPosition":8,"frontMatter":{"title":"Inheriting Classes","description":"How to inherit nanos world Classes","sidebar_position":8,"tags":["scripting"]},"sidebar":"main","previous":{"title":"Extending Classes","permalink":"/de/docs/next/core-concepts/scripting/extending-classes"},"next":{"title":"Dimensions","permalink":"/de/docs/next/core-concepts/scripting/dimensions"}}');var i=s(74848),a=s(28453);const l={title:"Inheriting Classes",description:"How to inherit nanos world Classes",sidebar_position:8,tags:["scripting"]},o=void 0,r={},c=[{value:"Inheriting a Class",id:"inheriting-a-class",level:3},{value:"Multiple Inheritance",id:"multiple-inheritance",level:3},{value:"Overriding the Constructor",id:"overriding-the-constructor",level:3},{value:"Global Registry",id:"global-registry",level:3},{value:"Adding new Methods",id:"adding-new-methods",level:3},{value:"Overriding Existing Methods",id:"overriding-existing-methods",level:3},{value:"Calling Native Methods",id:"calling-native-methods",level:3},{value:"Calling Parent Methods",id:"calling-parent-methods",level:3},{value:"Overriding <code>__newindex</code>",id:"overriding-__newindex",level:3},{value:"Overriding <code>__index</code>",id:"overriding-__index",level:3},{value:"Overriding <code>__tostring</code>",id:"overriding-__tostring",level:3},{value:"Native Events",id:"native-events",level:3},{value:"Multiple Parents Example:",id:"multiple-parents-example",level:4},{value:"Client/Server Synchronization",id:"clientserver-synchronization",level:3},{value:"Custom Remote Events",id:"custom-remote-events",level:3},{value:"Class Custom Default Values",id:"class-custom-default-values",level:3},{value:"Class Register Event",id:"class-register-event",level:3}];function d(e){const n={admonition:"admonition",code:"code",h3:"h3",h4:"h4",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"How to inherit nanos world Classes. nanos world provides a built-in way of inheriting the built-in Classes"}),"\n",(0,i.jsx)(n.admonition,{type:"caution",children:(0,i.jsxs)(n.p,{children:["This feature is still ",(0,i.jsx)(n.strong,{children:"experimental"}),", you can try it out and provide feedback before it's full release!"]})}),"\n",(0,i.jsx)(n.h3,{id:"inheriting-a-class",children:"Inheriting a Class"}),"\n",(0,i.jsxs)(n.p,{children:["Inheriting a nanos world Class is really easy, for that you just need to use the ",(0,i.jsx)(n.code,{children:"Inherit"})," static method on the Class you want to inherit:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",metastring:"showLineNumbers",children:'-- Creates a new Class called "MyNewClass" inheriting from Prop\n-- and stores it in the variable MyNewClass\nMyNewClass = Prop.Inherit("MyNewClass")\n\n-- Spawn it using the default constructor\nlocal my_new_class_instance = MyNewClass(Vector(), Rotator(), "nanos-world::SM_Cube")\n'})}),"\n",(0,i.jsx)(n.h3,{id:"multiple-inheritance",children:"Multiple Inheritance"}),"\n",(0,i.jsx)(n.p,{children:"You can also inherit from other inherited classes:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",metastring:"showLineNumbers",children:'-- Creates a new Class called "MyNewSubClass" inheriting from MyNewClass\nMyNewSubClass = MyNewClass.Inherit("MyNewSubClass")\n\n-- Spawn it using the default constructor\nlocal instance = MyNewSubClass(Vector(), Rotator(), "nanos-world::SM_Cube")\n'})}),"\n",(0,i.jsx)(n.h3,{id:"overriding-the-constructor",children:"Overriding the Constructor"}),"\n",(0,i.jsxs)(n.p,{children:["You can create your own Constructor for your entities, for that you need to define the ",(0,i.jsx)(n.code,{children:"Constructor"})," method:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",metastring:"showLineNumbers",children:'-- Defines my constructor with any parameters you desire\nfunction MyNewClass:Constructor(location, rotation)\n    -- Do any kind of logic here\n    location = location + Vector(0, 0, 100)\n\n    -- Calls Super Constructor to finalize the construction\n    -- This is the original constructor (in this case from Prop)\n    -- This is mandatory, if you don\'t call it, it will throw an error\n    -- You will only be able to access original and your own class\n    -- methods after calling it, when the class is completely spawned\n    self.Super:Constructor(location, rotation, "nanos-world::SM_Cube")\n\n    -- Now it\'s allowed to class methods\n    self:SetMaterialColorParameter("Tint", Color.RED)\nend\n\n-- Spawn it using your custom constructor\nlocal my_new_class_instance = MyNewClass(Vector(123, 456, 100), Rotator())\n'})}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["Inside the constructor, the entity is not fully spawned yet, so you cannot call other entity methods besides ",(0,i.jsx)(n.code,{children:"self.Super:Constructor"}),". Here you should just use to validate constructor parameters, and use ",(0,i.jsx)(n.code,{children:"Spawn"})," event to fully setup the entity."]})}),"\n",(0,i.jsx)(n.h3,{id:"global-registry",children:"Global Registry"}),"\n",(0,i.jsx)(n.p,{children:"Through the parent class, we can get a list of all children classes of that class, having a global registry of all existing classes!"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",metastring:"showLineNumbers",children:"local children_classes = ToolGun.GetInheritedClasses()\nfor _, class in pairs(children_classes) do\n    -- 'class' is a custom inherited class! we can spawn it\n    local p = class()\nend\n"})}),"\n",(0,i.jsx)(n.h3,{id:"adding-new-methods",children:"Adding new Methods"}),"\n",(0,i.jsxs)(n.p,{children:["Adding new methods for new classes is very straightforward, let's say we want to add a new method for ",(0,i.jsx)(n.strong,{children:"MyNewClass"}),", we just do that:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",metastring:"showLineNumbers",children:'function MyNewClass:Explode()\n    -- Spawns a particle\n    Particle(self:GetLocation(), Rotator(), "nanos-world::P_Explosion")\n\n    -- Destroys myself\n    self:Destroy()\nend\n'})}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["Within your methods, you can access the called entity instance with ",(0,i.jsx)(n.code,{children:"self"}),"."]})}),"\n",(0,i.jsx)(n.p,{children:"And then you are able to call it as usual:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",metastring:"showLineNumbers",children:"my_new_class_instance:Explode()\n"})}),"\n",(0,i.jsx)(n.h3,{id:"overriding-existing-methods",children:"Overriding Existing Methods"}),"\n",(0,i.jsx)(n.p,{children:"Besides creating new methods, it's possible to override existing ones, for that just redefine them:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",metastring:"showLineNumbers",children:"function MyNewClass:SetLocation(new_location)\n    -- Do any kind of logic here\n    new_location = new_location + Vector(0, 0, 100)\n\n    -- Call Super to set the location to the parent Prop\n    self.Super:SetLocation(new_location)\nend\n"})}),"\n",(0,i.jsx)(n.h3,{id:"calling-native-methods",children:"Calling Native Methods"}),"\n",(0,i.jsxs)(n.p,{children:["To call native Class methods, you can use the special variable ",(0,i.jsx)(n.code,{children:"self.Super"}),", which will allow you accessing the native and original methods directly:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",metastring:"showLineNumbers",children:"function MyNewClass:GetRotation()\n    -- Calls original GetRotation and adds 90 to yaw\n    return self.Super:GetRotation() + Rotator(0, 90, 0)\nend\n"})}),"\n",(0,i.jsx)(n.h3,{id:"calling-parent-methods",children:"Calling Parent Methods"}),"\n",(0,i.jsxs)(n.p,{children:["Besides calling the original/native method with ",(0,i.jsx)(n.code,{children:"self.Super"}),", we can also call parent methods if you have nested inheritance."]}),"\n",(0,i.jsxs)(n.p,{children:["For that, you must use a special Lua syntax with ",(0,i.jsx)(n.code,{children:"PARENT_CLASS.METHOD_NAME(self, ...)"}),", for example:"]}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["In Lua, passing a value as the first parameter to a method while calling it with ",(0,i.jsx)(n.code,{children:"."})," will make that value appear as ",(0,i.jsx)(n.code,{children:"self"})," inside the called method (if the method was defined with ",(0,i.jsx)(n.code,{children:":"}),")."]})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",metastring:"showLineNumbers",children:'-- Inherits Prop\nMyNewClass = Prop.Inherit("MyNewClass")\n\nfunction MyNewClass:SetScale(scale)\n    -- Does some logic\n    scale = scale * 2\n\n    -- Calls Super (original Prop method)\n    self.Super:SetScale(scale) * 2\nend\n\n-- Inherits MyNewClass\nMyNewSubClass = MyNewClass.Inherit("MyNewSubClass")\n\nfunction MyNewSubClass:SetScale(scale)\n    -- Does some logic\n    scale = scale + Vector(2, 2, 2)\n\n    -- Calls Parent MyNewClass method with special syntax\n    MyNewClass.SetScale(self, scale)\nend\n'})}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsx)(n.p,{children:"This same rule applies for calling inherited Constructors!"})}),"\n",(0,i.jsxs)(n.h3,{id:"overriding-__newindex",children:["Overriding ",(0,i.jsx)(n.code,{children:"__newindex"})]}),"\n",(0,i.jsxs)(n.p,{children:["It is also possible to add a custom ",(0,i.jsx)(n.code,{children:"__newindex"})," metamethod on Inherited Classes."]}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"__newindex"})," metamethod is a function which is triggered when you attempt to ",(0,i.jsx)(n.strong,{children:"set"})," a value in an entity. E.g.: ",(0,i.jsx)(n.code,{children:"my_entity.something = 123"}),"."]})}),"\n",(0,i.jsxs)(n.p,{children:["For that, we just add a custom method called ",(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"newindex"})}),":"]}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:["The method name must be ",(0,i.jsx)(n.code,{children:"newindex"})," and not ",(0,i.jsx)(n.code,{children:"__newindex"})," as ",(0,i.jsx)(n.code,{children:"__newindex"})," is the native method used internally to make the inheritance to work."]})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",metastring:"showLineNumbers",children:'function MyNewClass:newindex(key, value)\n    Console.Log("Setting a %s value: %s = %s", tostring(self), key, tostring(value))\nend\n'})}),"\n",(0,i.jsxs)(n.p,{children:["An useful way of using ",(0,i.jsx)(n.code,{children:"__newindex"})," is overriding it to ",(0,i.jsx)(n.code,{children:"SetValue"})," automatically:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",metastring:"showLineNumbers",children:"function MyNewClass:newindex(key, value)\n    self:SetValue(key, value)\nend\n\n-- Example usage\nlocal my_entity = MyNewClass()\nmy_entity.amazing_value = 123\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"overriding-__index",children:["Overriding ",(0,i.jsx)(n.code,{children:"__index"})]}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"__index"})," metamethod is a function which is triggered when you attempt to ",(0,i.jsx)(n.strong,{children:"get"})," a value from an entity. E.g.: ",(0,i.jsx)(n.code,{children:"local value = my_entity.something"}),"."]})}),"\n",(0,i.jsxs)(n.p,{children:["For that, we just add a custom method called ",(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"index"})}),":"]}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:["The method name must be ",(0,i.jsx)(n.code,{children:"index"})," and not ",(0,i.jsx)(n.code,{children:"__index"})," as ",(0,i.jsx)(n.code,{children:"__index"})," is the native method used internally to make the inheritance to work."]})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",metastring:"showLineNumbers",children:'function MyNewClass:index(key)\n    Console.Log("Getting %s value: %s", tostring(self), key)\n    -- ... do something\n    return some_value\nend\n'})}),"\n",(0,i.jsxs)(n.p,{children:["You can also use ",(0,i.jsx)(n.code,{children:"__index"})," to return a method:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",metastring:"showLineNumbers",children:'function MyNewClass:index(key)\n    Console.Log("%s key not found: %s", tostring(self), key)\n\n    -- inside the redirected method you will have all the parameters passed originally\n    return function(self, param1, param2...)\n        -- ... do something\n        return "triggered!"\n    end\n\n    -- or you can even redirect to other member functions\n    return MyClass.SetLocation\nend\n\nlocal my_entity = MyNewClass()\nmy_entity:NonExistentMethod(123, "456")\n'})}),"\n",(0,i.jsxs)(n.p,{children:["An useful way of using ",(0,i.jsx)(n.code,{children:"__index"})," is overriding it to ",(0,i.jsx)(n.code,{children:"GetValue"})," automatically:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",metastring:"showLineNumbers",children:"function MyNewClass:index(key)\n    return self:GetValue(key)\nend\n\nlocal my_entity = MyNewClass()\nlocal amazing_value = my_entity.amazing_value\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"overriding-__tostring",children:["Overriding ",(0,i.jsx)(n.code,{children:"__tostring"})]}),"\n",(0,i.jsxs)(n.p,{children:["You can override ",(0,i.jsx)(n.code,{children:"__tostring"})," as well as usual:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",metastring:"showLineNumbers",children:'function MyNewClass:__tostring()\n    return "My Incredible Class!"\nend\n'})}),"\n",(0,i.jsx)(n.h3,{id:"native-events",children:"Native Events"}),"\n",(0,i.jsx)(n.p,{children:"All events which are triggered on an inherited Class will only trigger in that Class and it's parents, also the parameter passed is the custom entity itself, example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",metastring:"showLineNumbers",children:'Prop.Subscribe("Spawn", function(self)\n    Console.Log("Spawned Prop: %s", tostring(self))\nend)\n\nMyNewClass.Subscribe("Spawn", function(self)\n    Console.Log("Spawned MyNewClass: %s", tostring(self))\nend)\n\nlocal my_entity = MyNewClass()\nlocal my_prop = Prop()\nlocal my_other_entity_inherited_from_prop = MyOtherClass()\n\n-- Will output:\n--  Spawned Prop: MyNewClass\n--  Spawned MyNewClass: MyNewClass\n--  Spawned Prop: Prop\n--  Spawned Prop: MyOtherClass\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Another way of subscribing is separating the definition and the subscription, this way you don't need the first ",(0,i.jsx)(n.code,{children:"self"})," parameter anymore:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",metastring:"showLineNumbers",children:'function MyNewClass:OnSpawn()\n    -- self is present is this context automatically\n    Console.Log("Spawned MyNewClass: %s", tostring(self))\nend\n\nMyNewClass.Subscribe("Spawn", MyNewClass.OnSpawn)\n'})}),"\n",(0,i.jsx)(n.h4,{id:"multiple-parents-example",children:"Multiple Parents Example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",metastring:"showLineNumbers",children:'MyNewClass = Prop.Inherit("MyNewClass")\nMyNewSubClass = MyNewClass.Inherit("MyNewSubClass")\nMyNewOtherSubClass = MyNewClass.Inherit("MyNewOtherSubClass")\n\nProp.Subscribe("Spawn", function(self)\n    Console.Log("Spawned Prop: %s", tostring(self))\nend)\n\nMyNewClass.Subscribe("Spawn", function(self)\n    Console.Log("Spawned MyNewClass: %s", tostring(self))\nend)\n\nMyNewSubClass.Subscribe("Spawn", function(self)\n    Console.Log("Spawned MyNewSubClass: %s", tostring(self))\nend)\n\nMyNewOtherSubClass.Subscribe("Spawn", function(self)\n    Console.Log("Spawned MyNewOtherSubClass: %s", tostring(self))\nend)\n\nlocal my_entity = MyNewSubClass()\n\n-- Will output:\n--  Spawned Prop: MyNewClass\n--  Spawned MyNewClass: MyNewClass\n--  Spawned MyNewSubClass: MyNewClass\n'})}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["Note that ",(0,i.jsx)(n.strong,{children:"Prop"})," and all ",(0,i.jsx)(n.strong,{children:"parent"})," Classes will still trigger events for all child Classes!"]})}),"\n",(0,i.jsx)(n.h3,{id:"clientserver-synchronization",children:"Client/Server Synchronization"}),"\n",(0,i.jsx)(n.p,{children:"If you define your entities on both Client and Server side, they will behave properly and in a synchronized way! Example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",metastring:'"title=Server/Index.lua" showLineNumbers',children:'MyNewClass = Prop.Inherit("MyNewClass")\n\nMyNewClass.Subscribe("Spawn", function(self)\n    Console.Log("Spawned MyNewClass: %s", tostring(self))\nend)\n\nlocal my_entity = MyNewClass()\n\n-- Will output:\n--  Spawned MyNewClass: MyNewClass\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",metastring:'"title=Client/Index.lua" showLineNumbers',children:'MyNewClass = Prop.Inherit("MyNewClass")\n\nMyNewClass.Subscribe("Spawn", function(self)\n    -- It was spawned on server and will spawn on Client as a MyNewClass properly\n    Console.Log("Spawned MyNewClass: %s", tostring(self))\nend)\n\n-- Will output:\n--  Spawned MyNewClass: MyNewClass\n'})}),"\n",(0,i.jsx)(n.h3,{id:"custom-remote-events",children:"Custom Remote Events"}),"\n",(0,i.jsxs)(n.p,{children:["It is also possible to trigger custom events on remote instances of your Class, using the methods ",(0,i.jsx)(n.code,{children:"CallRemoteEvent"})," or ",(0,i.jsx)(n.code,{children:"BroadcastRemoteEvent"}),", it works like the ",(0,i.jsx)(n.code,{children:"Events"})," class:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",metastring:'title="Client/Index.lua" showLineNumbers',children:'-- inherits the Class\nMyNewClass = Prop.Inherit("MyNewClass")\n\n-- defines a custom method\nfunction MyNewClass:OnMyCustomRemoteEvent(a, b)\n    Console.Log("OnMyCustomRemoteEvent!", tostring(self), a, b)\n    self:CallRemoteEvent("AnotherRemoteEvent", 456, "def")\nend\n\n-- subscribes for a custom remote event\nMyNewClass.SubscribeRemote("MyCustomRemoteEvent", MyNewClass.OnMyCustomRemoteEvent)\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",metastring:'title="Server/Index.lua" showLineNumbers',children:'-- inherits the Class\nMyNewClass = Prop.Inherit("MyNewClass")\n\n-- Note that server-side received remote events have the \'player as first parameter\nfunction MyNewClass:OnAnotherRemoteEvent(player, a, b)\n    Console.Log("OnAnotherRemoteEvent!", tostring(self), tostring(player), a, b)\nend\n\n-- subscribes for a custom remote event\nMyNewClass.SubscribeRemote("AnotherRemoteEvent", MyNewClass.OnAnotherRemoteEvent)\n\n-- spawns an entity and calls the custom remote event on that entity\nlocal p = MyNewClass(...)\np:BroadcastRemoteEvent("MyCustomRemoteEvent", 123, "abc")\n'})}),"\n",(0,i.jsx)(n.h3,{id:"class-custom-default-values",children:"Class Custom Default Values"}),"\n",(0,i.jsxs)(n.p,{children:["It is possible to set a list of default values to the Inherited Class when creating it, just pass it as the 2nd parameter to ",(0,i.jsx)(n.code,{children:"Inherit"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",metastring:"showLineNumbers",children:'-- inherits the Class\nMyNewClass = Prop.Inherit("MyNewClass", {\n    name = "My Name",\n    category = "breakable",\n    my_custom_param = 123\n})\n\nConsole.Log(MyNewClass.category)\n-- outputs "breakable"\n'})}),"\n",(0,i.jsx)(n.h3,{id:"class-register-event",children:"Class Register Event"}),"\n",(0,i.jsxs)(n.p,{children:["When you inherit a new class, the event ",(0,i.jsx)(n.code,{children:"ClassRegister"})," will be triggered on the parents classes, allowing Packages to know when a new Class is registered."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-lua",metastring:"showLineNumbers",children:'Prop.Subscribe("ClassRegister", function(class)\n    -- here we see an useful case for the default values\n    -- as we can access it here\n    Console.Log(MyNewClass.name) -- outputs "My Name\n    -- now we can do something (add to spawn menu?)\nend)\n\n-- inherits the Class\nMyNewClass = Prop.Inherit("MyNewClass", {\n    name = "My Name",\n    category = "breakable",\n    my_custom_param = 123\n})\n'})})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);