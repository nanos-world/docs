"use strict";(self.webpackChunkdocs_docusaurus=self.webpackChunkdocs_docusaurus||[]).push([[1478],{28453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>r});var i=n(96540);const o={},a=i.createContext(o);function s(e){const t=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),i.createElement(a.Provider,{value:t},e.children)}},59420:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>p,frontMatter:()=>s,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"core-concepts/scripting/traces-and-raycasting","title":"Traces & Raycasting","description":"How to use Traces & Raycasting to gather world information in runtime","source":"@site/docs/core-concepts/scripting/traces-and-raycasting.md","sourceDirName":"core-concepts/scripting","slug":"/core-concepts/scripting/traces-and-raycasting","permalink":"/docs/next/core-concepts/scripting/traces-and-raycasting","draft":false,"unlisted":false,"editUrl":"https://github.com/nanos-world/docs/edit/master/docs/core-concepts/scripting/traces-and-raycasting.md","tags":[{"inline":true,"label":"scripting","permalink":"/docs/next/tags/scripting"}],"version":"current","lastUpdatedBy":"Gabriel Tanasovici Nardy","lastUpdatedAt":1751020346000,"sidebarPosition":7,"frontMatter":{"title":"Traces & Raycasting","description":"How to use Traces & Raycasting to gather world information in runtime","sidebar_position":7,"tags":["scripting"]},"sidebar":"main","previous":{"title":"Artificial Intelligence","permalink":"/docs/next/core-concepts/scripting/artificial-intelligence"},"next":{"title":"Extending Classes","permalink":"/docs/next/core-concepts/scripting/extending-classes"}}');var o=n(74848),a=n(28453);const s={title:"Traces & Raycasting",description:"How to use Traces & Raycasting to gather world information in runtime",sidebar_position:7,tags:["scripting"]},r=void 0,c={},l=[];function d(e){const t={a:"a",admonition:"admonition",code:"code",img:"img",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.p,{children:"How to use Traces & Raycasting to gather world information in runtime."}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Traces"})," offer a method for reaching out in your maps and getting feedback on what is present along a line segment. You use them by providing two end points (a start and end location) and the physics system \u201ctraces\u201d a line segment between those points, reporting any Actors that it hits. Traces are essentially the same as ",(0,o.jsx)(t.strong,{children:"Raycasts"})," or ",(0,o.jsx)(t.strong,{children:"Raytraces"})," in other software packages."]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{src:n(83250).A+"",width:"1152",height:"435"})}),"\n",(0,o.jsx)(t.p,{children:"The following example will show you how to get what and where the player is looking at."}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-lua",metastring:'title="Client/Index.lua" showLineNumbers',children:'-- Traces at each 100ms\nTimer.SetInterval(function()\n    -- Gets the middle of the screen\n    local viewport_2D_center = Viewport.GetViewportSize() / 2\n\n    -- Deprojects to get the 3D Location for the middle of the screen\n    local viewport_3D = Viewport.DeprojectScreenToWorld(viewport_2D_center)\n\n    -- Makes a trace with the 3D Location and it\'s direction multiplied by 5000\n    -- Meaning it will trace 5000 units in that direction\n    local trace_max_distance = 5000\n\n    local start_location = viewport_3D.Position\n    local end_location = viewport_3D.Position + viewport_3D.Direction * trace_max_distance\n\n    -- Determine at which object we will be tracing for (WorldStatic - StaticMeshes - and PhysicsBody - Props)\n    local collision_trace = CollisionChannel.WorldStatic | CollisionChannel.PhysicsBody\n\n    -- Sets the trace modes (we want it to return Entity and Draws a Debug line)\n    local trace_mode = TraceMode.ReturnEntity | TraceMode.DrawDebug\n\n    -- Last parameter as true means it will draw a Debug Line in the traced segment\n    local trace_result = Trace.LineSingle(start_location, end_location, collision_trace, trace_mode)\n\n    -- If hit something draws a Debug Point at the location\n    if (trace_result.Success) then\n\n        -- Makes the point Red or Green if hit an Actor\n        local color = Color(1, 0, 0) -- Red\n\n        if (trace_result.Entity) then\n            color = Color(0, 1, 0) -- Green\n\n            -- Here you can check which actor you hit like\n            -- if (trace_result.Entity:GetType() == "Character") then ...\n        end\n\n        -- Draws a Debug Point at the Hit location for 5 seconds with size 10\n        Debug.DrawPoint(trace_result.Location, color, 5, 10)\n    end\nend, 100)\n'})}),"\n",(0,o.jsx)(t.admonition,{type:"tip",children:(0,o.jsxs)(t.p,{children:["As you could see, we can pass bit-wise operators to Trace for more than one ",(0,o.jsx)(t.a,{href:"/docs/next/scripting-reference/glossary/enums#collisionchannel",children:"CollisionChannel"})," at once! Use ",(0,o.jsx)(t.code,{children:"|"})," between the ",(0,o.jsx)(t.strong,{children:"CollisionChannels"})," to achieve that."]})})]})}function p(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},83250:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/traces-raycasting-fad2ddd4424e6c9b19e682b88acf4371.webp"}}]);