"use strict";(self.webpackChunkdocs_docusaurus=self.webpackChunkdocs_docusaurus||[]).push([[4223],{9727:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>p,frontMatter:()=>a,metadata:()=>r,toc:()=>l});var i=n(85893),o=n(11151);const a={title:"Traces & Raycasting",description:"How to use Traces & Raycasting to gather world information in runtime",sidebar_position:7,tags:["scripting"]},s=void 0,r={id:"core-concepts/scripting/traces-and-raycasting",title:"Traces & Raycasting",description:"How to use Traces & Raycasting to gather world information in runtime",source:"@site/versioned_docs/version-latest/core-concepts/scripting/traces-and-raycasting.md",sourceDirName:"core-concepts/scripting",slug:"/core-concepts/scripting/traces-and-raycasting",permalink:"/docs/core-concepts/scripting/traces-and-raycasting",draft:!1,unlisted:!1,editUrl:"https://github.com/nanos-world/docs/edit/master/versioned_docs/version-latest/core-concepts/scripting/traces-and-raycasting.md",tags:[{label:"scripting",permalink:"/docs/tags/scripting"}],version:"latest",lastUpdatedBy:"Gabriel T. Nardy",lastUpdatedAt:1702980814,formattedLastUpdatedAt:"Dec 19, 2023",sidebarPosition:7,frontMatter:{title:"Traces & Raycasting",description:"How to use Traces & Raycasting to gather world information in runtime",sidebar_position:7,tags:["scripting"]},sidebar:"main",previous:{title:"Artificial Intelligence",permalink:"/docs/core-concepts/scripting/artificial-intelligence"},next:{title:"Extending Classes",permalink:"/docs/core-concepts/scripting/extending-classes"}},c={},l=[];function d(e){const t={a:"a",admonition:"admonition",code:"code",img:"img",p:"p",pre:"pre",strong:"strong",...(0,o.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.p,{children:"How to use Traces & Raycasting to gather world information in runtime."}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Traces"})," offer a method for reaching out in your maps and getting feedback on what is present along a line segment. You use them by providing two end points (a start and end location) and the physics system \u201ctraces\u201d a line segment between those points, reporting any Actors that it hits. Traces are essentially the same as ",(0,i.jsx)(t.strong,{children:"Raycasts"})," or ",(0,i.jsx)(t.strong,{children:"Raytraces"})," in other software packages."]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{src:n(39341).Z+"",width:"1152",height:"435"})}),"\n",(0,i.jsx)(t.p,{children:"The following example will show you how to get what and where the player is looking at."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-lua",metastring:'title="Client/Index.lua"',children:'-- Traces at each 100ms\nTimer.SetInterval(function()\n    -- Gets the middle of the screen\n    local viewport_2D_center = Viewport.GetViewportSize() / 2\n\n    -- Deprojects to get the 3D Location for the middle of the screen\n    local viewport_3D = Viewport.DeprojectScreenToWorld(viewport_2D_center)\n\n    -- Makes a trace with the 3D Location and it\'s direction multiplied by 5000\n    -- Meaning it will trace 5000 units in that direction\n    local trace_max_distance = 5000\n\n    local start_location = viewport_3D.Position\n    local end_location = viewport_3D.Position + viewport_3D.Direction * trace_max_distance\n\n    -- Determine at which object we will be tracing for (WorldStatic - StaticMeshes - and PhysicsBody - Props)\n    local collision_trace = CollisionChannel.WorldStatic | CollisionChannel.PhysicsBody\n\n    -- Sets the trace modes (we want it to return Entity and Draws a Debug line)\n    local trace_mode = TraceMode.ReturnEntity | TraceMode.DrawDebug\n\n    -- Last parameter as true means it will draw a Debug Line in the traced segment\n    local trace_result = Trace.LineSingle(start_location, end_location, collision_trace, trace_mode)\n\n    -- If hit something draws a Debug Point at the location\n    if (trace_result.Success) then\n\n        -- Makes the point Red or Green if hit an Actor\n        local color = Color(1, 0, 0) -- Red\n\n        if (trace_result.Entity) then\n            color = Color(0, 1, 0) -- Green\n\n            -- Here you can check which actor you hit like\n            -- if (trace_result.Entity:GetType() == "Character") then ...\n        end\n\n        -- Draws a Debug Point at the Hit location for 5 seconds with size 10\n        Debug.DrawPoint(trace_result.Location, color, 5, 10)\n    end\nend, 100)\n'})}),"\n",(0,i.jsx)(t.admonition,{type:"tip",children:(0,i.jsxs)(t.p,{children:["As you could see, we can pass bit-wise operators to Trace for more than one ",(0,i.jsx)(t.a,{href:"/docs/scripting-reference/glossary/enums#collisionchannel",children:"CollisionChannel"})," at once! Use ",(0,i.jsx)(t.code,{children:"|"})," between the ",(0,i.jsx)(t.strong,{children:"CollisionChannels"})," to achieve that."]})})]})}function p(e={}){const{wrapper:t}={...(0,o.a)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},39341:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/traces-raycasting-fad2ddd4424e6c9b19e682b88acf4371.webp"},11151:(e,t,n)=>{n.d(t,{Z:()=>r,a:()=>s});var i=n(67294);const o={},a=i.createContext(o);function s(e){const t=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),i.createElement(a.Provider,{value:t},e.children)}}}]);