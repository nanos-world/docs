"use strict";(self.webpackChunkdocs_docusaurus=self.webpackChunkdocs_docusaurus||[]).push([[5337],{28453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>i});var o=n(96540);const s={},a=o.createContext(s);function r(e){const t=o.useContext(a);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),o.createElement(a.Provider,{value:t},e.children)}},77669:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>p,frontMatter:()=>r,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"core-concepts/scripting/traces-and-raycasting","title":"Tra\xe7os & Raycasting","description":"Como usar trilhas & Raycasting para coletar informa\xe7\xf5es do mundo em tempo de execu\xe7\xe3o","source":"@site/i18n/pt-BR/docusaurus-plugin-content-docs/current/core-concepts/scripting/traces-and-raycasting.md","sourceDirName":"core-concepts/scripting","slug":"/core-concepts/scripting/traces-and-raycasting","permalink":"/pt-BR/docs/next/core-concepts/scripting/traces-and-raycasting","draft":false,"unlisted":false,"editUrl":"https://crowdin.com/project/nanos-world-docs/pt-BR","tags":[{"inline":true,"label":"script","permalink":"/pt-BR/docs/next/tags/script"}],"version":"current","sidebarPosition":7,"frontMatter":{"title":"Tra\xe7os & Raycasting","description":"Como usar trilhas & Raycasting para coletar informa\xe7\xf5es do mundo em tempo de execu\xe7\xe3o","sidebar_position":7,"tags":["script"]},"sidebar":"main","previous":{"title":"Intelig\xeancia Artificial","permalink":"/pt-BR/docs/next/core-concepts/scripting/artificial-intelligence"},"next":{"title":"Extending Classes","permalink":"/pt-BR/docs/next/core-concepts/scripting/extending-classes"}}');var s=n(74848),a=n(28453);const r={title:"Tra\xe7os & Raycasting",description:"Como usar trilhas & Raycasting para coletar informa\xe7\xf5es do mundo em tempo de execu\xe7\xe3o",sidebar_position:7,tags:["script"]},i=void 0,c={},l=[];function d(e){const t={a:"a",admonition:"admonition",code:"code",img:"img",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.p,{children:"Como usar trilhas & Raycasting para coletar informa\xe7\xf5es do mundo em tempo de execu\xe7\xe3o."}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Traces"})," oferecem um m\xe9todo para alcan\xe7ar seus mapas e obter feedback sobre o que est\xe1 presente ao longo de um segmento de linha. You use them by providing two end points (a start and end location) and the physics system \u201ctraces\u201d a line segment between those points, reporting any Actors that it hits. As trilhas s\xe3o essencialmente as mesmas que ",(0,s.jsx)(t.strong,{children:"Raycasts"})," ou ",(0,s.jsx)(t.strong,{children:"Raytraces"})," em outros pacotes de software."]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{src:n(83250).A+"",width:"1152",height:"435"})}),"\n",(0,s.jsx)(t.p,{children:"O exemplo a seguir mostrar\xe1 como obter o qu\xea e para onde o jogador est\xe1 olhando."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",metastring:'title="Client/Index.lua" showLineNumbers',children:'-- Traces at each 100ms\nTimer.SetInterval(function()\n    -- Gets the middle of the screen\n    local viewport_2D_center = Viewport.GetViewportSize() / 2\n\n    -- Deprojects to get the 3D Location for the middle of the screen\n    local viewport_3D = Viewport.DeprojectScreenToWorld(viewport_2D_center)\n\n    -- Makes a trace with the 3D Location and it\'s direction multiplied by 5000\n    -- Meaning it will trace 5000 units in that direction\n    local trace_max_distance = 5000\n\n    local start_location = viewport_3D.Position\n    local end_location = viewport_3D.Position + viewport_3D.Direction * trace_max_distance\n\n    -- Determine at which object we will be tracing for (WorldStatic - StaticMeshes - and PhysicsBody - Props)\n    local collision_trace = CollisionChannel.WorldStatic | CollisionChannel.PhysicsBody\n\n    -- Sets the trace modes (we want it to return Entity and Draws a Debug line)\n    local trace_mode = TraceMode.ReturnEntity | TraceMode.DrawDebug\n\n    -- Last parameter as true means it will draw a Debug Line in the traced segment\n    local trace_result = Trace.LineSingle(start_location, end_location, collision_trace, trace_mode)\n\n    -- If hit something draws a Debug Point at the location\n    if (trace_result.Success) then\n\n        -- Makes the point Red or Green if hit an Actor\n        local color = Color(1, 0, 0) -- Red\n\n        if (trace_result.Entity) then\n            color = Color(0, 1, 0) -- Green\n\n            -- Here you can check which actor you hit like\n            -- if (trace_result.Entity:GetType() == "Character") then ...\n        end\n\n        -- Draws a Debug Point at the Hit location for 5 seconds with size 10\n        Debug.DrawPoint(trace_result.Location, color, 5, 10)\n    end\nend, 100)\n'})}),"\n",(0,s.jsx)(t.admonition,{type:"tip",children:(0,s.jsxs)(t.p,{children:["As you could see, we can pass bit-wise operators to Trace for more than one ",(0,s.jsx)(t.a,{href:"/pt-BR/docs/next/scripting-reference/glossary/enums#collisionchannel",children:"CollisionChannel"})," at once! Use ",(0,s.jsx)(t.code,{children:"\u27b2"})," entre os ",(0,s.jsx)(t.strong,{children:"CollisionChannels"})," para conseguir isso."]})})]})}function p(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},83250:(e,t,n)=>{n.d(t,{A:()=>o});const o=n.p+"assets/images/traces-raycasting-fad2ddd4424e6c9b19e682b88acf4371.webp"}}]);