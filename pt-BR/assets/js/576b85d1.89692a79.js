"use strict";(self.webpackChunkdocs_docusaurus=self.webpackChunkdocs_docusaurus||[]).push([[7219],{28453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>r});var a=n(96540);const c={},o=a.createContext(c);function s(e){const t=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(c):e.components||c:s(e.components),a.createElement(o.Provider,{value:t},e.children)}},91224:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>i,contentTitle:()=>r,default:()=>u,frontMatter:()=>s,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"scripting-reference/static-classes/trace","title":"\ud83d\udd0d Trace","description":"Trace a ray against the world and get collided objects information.","source":"@site/i18n/pt-BR/docusaurus-plugin-content-docs/current/scripting-reference/static-classes/trace.mdx","sourceDirName":"scripting-reference/static-classes","slug":"/scripting-reference/static-classes/trace","permalink":"/pt-BR/docs/next/scripting-reference/static-classes/trace","draft":false,"unlisted":false,"editUrl":"https://crowdin.com/project/nanos-world-docs/pt-BR","tags":[{"inline":true,"label":"static-class","permalink":"/pt-BR/docs/next/tags/static-class"}],"version":"current","lastUpdatedBy":null,"lastUpdatedAt":null,"frontMatter":{"title":"\ud83d\udd0d Trace","description":"Trace a ray against the world and get collided objects information.","tags":["static-class"]},"sidebar":"main","previous":{"title":"\u23f1\ufe0f Timer","permalink":"/pt-BR/docs/next/scripting-reference/static-classes/timer"},"next":{"title":"\ud83d\udcfa Viewport","permalink":"/pt-BR/docs/next/scripting-reference/static-classes/viewport"}}');var c=n(74848),o=n(28453);const s={title:"\ud83d\udd0d Trace",description:"Trace a ray against the world and get collided objects information.",tags:["static-class"]},r=void 0,i={},l=[{value:"\ud83c\udf92\xa0Examples",id:"examples",level:2},{value:"\ud83d\uddff\xa0Static Functions",id:"static-functions",level:2},{value:"\ud83d\ude80\xa0Events",id:"events",level:2}];function d(e){const t={code:"code",h2:"h2",pre:"pre",...(0,o.R)(),...e.components},{EventsDeclaration:n,HeaderDeclaration:a,StaticFunctionsDeclaration:s}=t;return n||p("EventsDeclaration",!0),a||p("HeaderDeclaration",!0),s||p("StaticFunctionsDeclaration",!0),(0,c.jsxs)(c.Fragment,{children:[(0,c.jsx)(a,{type:"StaticClass",name:"Trace",is_static:!0}),"\n",(0,c.jsx)(t.h2,{id:"examples",children:"\ud83c\udf92\xa0Examples"}),"\n",(0,c.jsx)(t.pre,{children:(0,c.jsx)(t.code,{className:"language-lua",metastring:'title="Client/Index.lua"',children:'    -- Gets the local player\n    local local_player = Client.GetLocalPlayer()\n\n    -- Gets the camera rotation and location\n    local camera_rotation = local_player:GetCameraRotation()\n    local start_location = local_player:GetCameraLocation()\n\n    -- Calculates the direction vector based on the camera rotation\n    local direction =  camera_rotation:GetForwardVector()\n\n    -- Calculates the end location of the trace\n    -- (start location + 20000 units in the direction of the camera)\n    local end_location = start_location + direction * 20000\n\n    -- Filter everything we want to trace (e.g. WorldStatic, WorldDynamic, PhysicsBody, Vehicle)\n    local collision_trace = CollisionChannel.WorldStatic | CollisionChannel.WorldDynamic | CollisionChannel.PhysicsBody | CollisionChannel.Vehicle\n\n    -- Define the parameters for the trace\n    -- TraceMode.TraceOnlyVisibility means we only want to trace against objects that are visible\n    -- TraceMode.DrawDebug means we want to draw debug lines for the trace for visualization\n    -- TraceMode.TraceComplex means we want to trace against complex collision shapes\n    -- TraceMode.ReturnEntity means we want to return the entity that was hit by the trace\n    local trace_mode = TraceMode.TraceOnlyVisibility | TraceMode.DrawDebug | TraceMode.TraceComplex | TraceMode.ReturnEntity\n\n    -- Do the trace\n    local trace_result = Trace.LineSingle(start_location, end_location, collision_trace, trace_mode)\n\n    -- If the trace was successful\n    if (trace_result.Success) then\n        -- And we got an entity, print the name of the collided entity, otherwise just print the location\n        if (trace_result.Entity) then\n            Console.Log("Trace Success! Entity: " .. trace_result.Entity:GetClass():GetName() .. ". Location: " .. tostring(trace_result.Location))\n        else\n            Console.Log("Trace Success! Location: " .. tostring(trace_result.Location))\n        end\n    else\n        -- If the trace was not successful, print a message\n        Console.Log("Failed to trace")\n    end\n'})}),"\n",(0,c.jsx)(t.h2,{id:"static-functions",children:"\ud83d\uddff\xa0Static Functions"}),"\n",(0,c.jsx)(s,{type:"StaticClass",name:"Trace"}),"\n",(0,c.jsx)(t.h2,{id:"events",children:"\ud83d\ude80\xa0Events"}),"\n",(0,c.jsx)(n,{type:"StaticClass",name:"Trace"})]})}function u(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,c.jsx)(t,{...e,children:(0,c.jsx)(d,{...e})}):d(e)}function p(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}}}]);